<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1024">
    <title>NetCard Architect Ultra | Professional Suite</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;900&family=JetBrains+Mono&family=Playfair+Display:wght@700&family=Bebas+Neue&display=swap" rel="stylesheet">
    <style id="main-styles">
        html, body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Inter', sans-serif;
            color: #f1f5f9;
        }

        .glass-panel {
            background: rgba(15, 15, 15, 0.9);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.08);
        }

        .control-label {
            font-size: 10px;
            font-weight: 900;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 0.75rem;
            display: block;
        }

        input[type="range"] { 
            accent-color: #3b82f6; 
            height: 4px;
            appearance: none;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
        }

        .draggable {
            cursor: move;
            user-select: none;
            pointer-events: all;
        }
        
        .draggable:hover {
            outline: 2px dashed #3b82f6;
            outline-offset: 4px;
        }

        .selected-element {
            outline: 2px solid #3b82f6 !important;
            outline-offset: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; }

        .btn-active { background-color: #2563eb !important; color: white !important; }
        .btn-inactive { background-color: rgba(255,255,255,0.05); color: #94a3b8; }
        
        #main-svg {
            filter: drop-shadow(0 25px 50px rgba(0,0,0,0.8));
            touch-action: none;
        }

        .history-btn:disabled { opacity: 0.2; cursor: not-allowed; }
    </style>
</head>
<body class="flex flex-col">

    <nav class="h-14 bg-black border-b border-white/5 flex items-center justify-between px-6 shrink-0 z-50">
        <div class="flex items-center gap-6">
            <div class="flex items-center gap-4">
                <div class="w-8 h-8 bg-blue-600 rounded flex items-center justify-center">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3"><rect width="20" height="14" x="2" y="5" rx="2"/><line x1="2" x2="22" y1="10" y2="10"/></svg>
                </div>
                <h1 class="font-black text-lg tracking-tighter uppercase">NetCard <span class="text-blue-500">Ultra</span></h1>
            </div>

            <div class="flex items-center gap-2 border-l border-white/10 pl-6">
                <button id="undoBtn" onclick="undo()" class="history-btn p-2 hover:bg-white/10 rounded transition-colors" title="Undo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M9 14L4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/></svg>
                </button>
                <button id="redoBtn" onclick="redo()" class="history-btn p-2 hover:bg-white/10 rounded transition-colors" title="Redo">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M15 14l5-5-5-5"/><path d="M20 9H9.5A5.5 5.5 0 0 0 4 14.5v0A5.5 5.5 0 0 0 9.5 20H13"/></svg>
                </button>
            </div>
        </div>

        <div class="flex items-center gap-4">
            <div class="flex bg-white/5 rounded p-1">
                <button onclick="addTextBox()" class="text-[9px] font-bold px-3 py-1.5 hover:bg-white/10 rounded transition-all">TEXT</button>
                <button onclick="addShape('rect')" class="text-[9px] font-bold px-3 py-1.5 hover:bg-white/10 rounded transition-all">SQUARE</button>
                <button onclick="addShape('circle')" class="text-[9px] font-bold px-3 py-1.5 hover:bg-white/10 rounded transition-all">CIRCLE</button>
            </div>
            <button id="exportBtn" class="bg-blue-600 hover:bg-blue-500 text-white px-5 py-2 rounded font-bold text-xs flex items-center gap-2 transition-all">
                EXPORT PNG
            </button>
        </div>
    </nav>

    <div class="flex flex-1 overflow-hidden">
        <aside class="w-80 glass-panel overflow-y-auto p-6 shrink-0 custom-scrollbar">
            <div class="space-y-8 pb-12">
                
                <section>
                    <span class="control-label">Layout</span>
                    <div class="grid grid-cols-2 gap-2">
                        <button onclick="setOrient('H')" id="btn-H" class="p-2 rounded text-[10px] font-bold btn-active">HORIZONTAL</button>
                        <button onclick="setOrient('V')" id="btn-V" class="p-2 rounded text-[10px] font-bold btn-inactive">VERTICAL</button>
                    </div>
                </section>

                <section id="elementEditor" class="hidden">
                    <span class="control-label">Edit Selection</span>
                    <div class="bg-white/5 p-4 rounded border border-white/10 space-y-4">
                        <div id="textOnly">
                            <label class="text-[9px] text-gray-500 block mb-1">FONT & CONTENT</label>
                            <select id="fontSelect" onchange="updateSelectedElement('fontFamily', this.value)" class="w-full bg-black border border-white/10 rounded p-2 text-xs text-white mb-2">
                                <option value="Inter">Modern (Sans)</option>
                                <option value="'Playfair Display'">Executive (Serif)</option>
                                <option value="'JetBrains Mono'">Cyber (Mono)</option>
                                <option value="'Bebas Neue'">Bauhaus (Bold)</option>
                            </select>
                            <input type="text" id="contentInput" oninput="updateSelectedElement('text', this.value)" class="w-full bg-black border border-white/10 rounded p-2 text-xs text-white">
                        </div>

                        <div id="imageOnly" class="hidden">
                            <label class="text-[9px] text-gray-500 block mb-1">IMAGE SHAPE</label>
                            <div class="grid grid-cols-3 gap-1">
                                <button onclick="updateSelectedElement('clip', 'rect')" class="bg-black border border-white/10 p-1 rounded text-[8px]">SQUARE</button>
                                <button onclick="updateSelectedElement('clip', 'circle')" class="bg-black border border-white/10 p-1 rounded text-[8px]">CIRCLE</button>
                                <button onclick="updateSelectedElement('clip', 'hex')" class="bg-black border border-white/10 p-1 rounded text-[8px]">HEX</button>
                            </div>
                        </div>

                        <div>
                            <label class="text-[9px] text-gray-500 block mb-1">SIZE / SCALE</label>
                            <input type="range" id="sizeInput" min="5" max="500" oninput="updateSelectedElement('scale', this.value)" class="w-full">
                        </div>

                        <div>
                            <label class="text-[9px] text-gray-500 block mb-1">COLOR & OPACITY</label>
                            <div class="flex gap-2">
                                <input type="color" id="colorInput" oninput="updateSelectedElement('fill', this.value)" class="flex-1 h-8 bg-transparent cursor-pointer">
                                <input type="range" id="opacityInput" min="0" max="1" step="0.1" oninput="updateSelectedElement('opacity', this.value)" class="w-24">
                            </div>
                        </div>

                        <button onclick="deleteSelected()" class="w-full py-2 bg-red-900/20 text-red-500 text-[10px] font-bold rounded hover:bg-red-600 hover:text-white transition-all">DELETE</button>
                    </div>
                </section>

                <section>
                    <span class="control-label">Identity Assets</span>
                    <label class="block w-full bg-white/5 border-2 border-dashed border-white/10 rounded p-4 text-center cursor-pointer hover:border-blue-500/50 transition-all">
                        <span class="text-[9px] font-bold text-gray-500">UPLOAD IMAGE</span>
                        <input type="file" id="assetInput" onchange="handleFile(this)" class="hidden" accept="image/*">
                    </label>
                </section>

                <section>
                    <span class="control-label">Canvas Master</span>
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <span class="text-xs text-gray-400">Background</span>
                            <input type="color" id="col-bg" value="#0a0a0a" oninput="updateCanvasStyle()" class="h-6 w-12 bg-transparent">
                        </div>
                    </div>
                </section>
            </div>
        </aside>

        <main class="flex-1 bg-[#020202] relative flex items-center justify-center p-8 overflow-hidden">
            <div id="canvasWrapper" class="relative w-full max-w-[850px] aspect-[1050/600] transition-all">
                <svg id="main-svg" viewBox="0 0 1050 600" class="w-full h-full rounded shadow-2xl bg-black">
                    <defs id="svg-defs"></defs>
                    <rect id="canvas-bg" width="100%" height="100%" fill="#0a0a0a" />
                    <g id="elements-layer"></g>
                </svg>
            </div>
        </main>
    </div>

    <canvas id="exportCanvas" class="hidden"></canvas>

    <script>
        const state = {
            orientation: 'H',
            elements: [
                { id: 'el-name', type: 'text', text: 'ALEXANDER VANCE', x: 80, y: 400, fontSize: 64, fill: '#ffffff', fontFamily: 'Inter', fontWeight: '900', opacity: 1 },
                { id: 'el-role', type: 'text', text: 'CREATIVE DIRECTOR', x: 80, y: 460, fontSize: 24, fill: '#3b82f6', fontFamily: 'Inter', fontWeight: '700', opacity: 1 },
                { id: 'el-qr', type: 'image', href: '', x: 850, y: 400, width: 120, height: 120, opacity: 1, clip: 'rect' }
            ],
            selectedId: null,
            history: [],
            historyIndex: -1,
            isDragging: false,
            dragTarget: null,
            dragOffset: { x: 0, y: 0 }
        };

        const svg = document.getElementById('main-svg');
        const elementsLayer = document.getElementById('elements-layer');
        const editor = document.getElementById('elementEditor');

        // --- History Logic ---
        function saveHistory() {
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }
            state.history.push(JSON.stringify(state.elements));
            if (state.history.length > 50) state.history.shift();
            state.historyIndex = state.history.length - 1;
            updateHistoryButtons();
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                state.elements = JSON.parse(state.history[state.historyIndex]);
                render();
                updateHistoryButtons();
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                state.elements = JSON.parse(state.history[state.historyIndex]);
                render();
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = state.historyIndex <= 0;
            document.getElementById('redoBtn').disabled = state.historyIndex >= state.history.length - 1;
        }

        // --- Core ---
        async function init() {
            const qrUrl = await generateQR("https://apps.circulareagle.com");
            const qrEl = state.elements.find(e => e.id === 'el-qr');
            if (qrEl) qrEl.href = qrUrl;
            saveHistory();
            render();
            setupInteractions();
        }

        async function generateQR(data) {
            return `https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=${encodeURIComponent(data)}&color=ffffff&bgcolor=000000`;
        }

        function setOrient(o) {
            state.orientation = o;
            const wrapper = document.getElementById('canvasWrapper');
            document.getElementById('btn-H').className = o === 'H' ? 'p-2 rounded text-[10px] font-bold btn-active' : 'p-2 rounded text-[10px] font-bold btn-inactive';
            document.getElementById('btn-V').className = o === 'V' ? 'p-2 rounded text-[10px] font-bold btn-active' : 'p-2 rounded text-[10px] font-bold btn-inactive';

            if(o === 'H') {
                wrapper.className = "relative w-full max-w-[850px] aspect-[1050/600]";
                svg.setAttribute('viewBox', '0 0 1050 600');
            } else {
                wrapper.className = "relative h-full max-h-[850px] aspect-[600/1050]";
                svg.setAttribute('viewBox', '0 0 600 1050');
            }
            render(); 
        }

        function updateCanvasStyle() {
            document.getElementById('canvas-bg').setAttribute('fill', document.getElementById('col-bg').value);
        }

        // --- Element Creation ---
        function addTextBox() {
            state.elements.push({
                id: 'txt-' + Date.now(),
                type: 'text',
                text: 'New Text',
                x: 150, y: 150, fontSize: 30, fill: '#ffffff', fontFamily: 'Inter', fontWeight: '400', opacity: 1
            });
            saveHistory();
            render();
        }

        function addShape(shapeType) {
            const id = 'shape-' + Date.now();
            if (shapeType === 'rect') {
                state.elements.push({ id, type: 'rect', fill: '#3b82f6', opacity: 0.8, x: 200, y: 200, width: 100, height: 100 });
            } else {
                state.elements.push({ id, type: 'circle', fill: '#3b82f6', opacity: 0.8, cx: 250, cy: 250, r: 50 });
            }
            saveHistory();
            render();
        }

        function handleFile(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = e => {
                    state.elements.push({
                        id: 'img-' + Date.now(),
                        type: 'image',
                        href: e.target.result,
                        x: 100, y: 100, width: 200, height: 200, opacity: 1, clip: 'rect'
                    });
                    saveHistory();
                    render();
                };
                reader.readAsDataURL(input.files[0]);
            }
        }

        // --- Interaction Logic ---
        function getMouseCoords(e) {
            const CTM = svg.getScreenCTM();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: (clientX - CTM.e) / CTM.a,
                y: (clientY - CTM.f) / CTM.d
            };
        }

        function setupInteractions() {
            svg.addEventListener('mousedown', startDrag);
            window.addEventListener('mousemove', drag);
            window.addEventListener('mouseup', endDrag);

            svg.addEventListener('touchstart', startDrag, {passive: false});
            window.addEventListener('touchmove', drag, {passive: false});
            window.addEventListener('touchend', endDrag);
        }

        function startDrag(e) {
            const target = e.target.closest('.draggable');
            if (!target) {
                if (e.target.id === 'main-svg' || e.target.id === 'canvas-bg') {
                   state.selectedId = null;
                   editor.classList.add('hidden');
                   render();
                }
                return;
            }

            const id = target.getAttribute('data-id');
            selectElement(id);

            state.isDragging = true;
            state.dragTarget = state.elements.find(el => el.id === id);
            
            const coords = getMouseCoords(e);

            if (state.dragTarget.type === 'circle') {
                state.dragOffset.x = coords.x - (state.dragTarget.cx || 0);
                state.dragOffset.y = coords.y - (state.dragTarget.cy || 0);
            } else {
                state.dragOffset.x = coords.x - (state.dragTarget.x || 0);
                state.dragOffset.y = coords.y - (state.dragTarget.y || 0);
            }
            
            if (e.cancelable) e.preventDefault();
        }

        function drag(e) {
            if (!state.isDragging || !state.dragTarget) return;
            const coords = getMouseCoords(e);

            if (state.dragTarget.type === 'circle') {
                state.dragTarget.cx = coords.x - state.dragOffset.x;
                state.dragTarget.cy = coords.y - state.dragOffset.y;
            } else {
                state.dragTarget.x = coords.x - state.dragOffset.x;
                state.dragTarget.y = coords.y - state.dragOffset.y;
            }
            render();
            if (e.cancelable) e.preventDefault();
        }

        function endDrag() {
            if (state.isDragging) saveHistory();
            state.isDragging = false;
        }

        function selectElement(id) {
            state.selectedId = id;
            const el = state.elements.find(e => e.id === id);
            editor.classList.remove('hidden');
            
            document.getElementById('textOnly').style.display = el.type === 'text' ? 'block' : 'none';
            document.getElementById('imageOnly').style.display = el.type === 'image' ? 'block' : 'none';
            
            if (el.type === 'text') {
                document.getElementById('fontSelect').value = el.fontFamily;
                document.getElementById('contentInput').value = el.text;
                document.getElementById('sizeInput').value = el.fontSize;
            } else if (el.type === 'image' || el.type === 'rect') {
                document.getElementById('sizeInput').value = el.width;
            } else if (el.type === 'circle') {
                document.getElementById('sizeInput').value = el.r;
            }

            document.getElementById('colorInput').value = el.fill || '#ffffff';
            document.getElementById('opacityInput').value = el.opacity;
            render();
        }

        function updateSelectedElement(prop, value) {
            if (!state.selectedId) return;
            const el = state.elements.find(e => e.id === state.selectedId);
            
            if (prop === 'scale') {
                const val = parseInt(value);
                if (el.type === 'text') el.fontSize = val;
                else if (el.type === 'image' || el.type === 'rect') { el.width = val; el.height = val; }
                else if (el.type === 'circle') el.r = val;
            } else {
                el[prop] = value;
            }
            
            render();
            clearTimeout(window.saveTimeout);
            window.saveTimeout = setTimeout(saveHistory, 500);
        }

        function deleteSelected() {
            state.elements = state.elements.filter(e => e.id !== state.selectedId);
            state.selectedId = null;
            editor.classList.add('hidden');
            saveHistory();
            render();
        }

        // --- Rendering Engine ---
        function render() {
            let html = '';
            let defs = '';

            state.elements.forEach(el => {
                const isSelected = el.id === state.selectedId;
                const cls = `draggable ${isSelected ? 'selected-element' : ''}`;
                
                if (el.type === 'text') {
                    html += `<text data-id="${el.id}" x="${el.x}" y="${el.y}" fill="${el.fill}" opacity="${el.opacity}" font-family="${el.fontFamily}" font-size="${el.fontSize}" font-weight="${el.fontWeight}" class="${cls}">${el.text}</text>`;
                } 
                else if (el.type === 'image') {
                    const clipId = `clip-${el.id}`;
                    if (el.clip === 'circle') {
                        defs += `<clipPath id="${clipId}"><circle cx="${el.x + el.width/2}" cy="${el.y + el.height/2}" r="${el.width/2}" /></clipPath>`;
                    } else if (el.clip === 'hex') {
                        const r = el.width/2;
                        const cx = el.x + r;
                        const cy = el.y + r;
                        let pts = "";
                        for(let i=0; i<6; i++) {
                            let angle = (i * 60) * Math.PI / 180;
                            pts += `${cx + r * Math.cos(angle)},${cy + r * Math.sin(angle)} `;
                        }
                        defs += `<clipPath id="${clipId}"><polygon points="${pts}" /></clipPath>`;
                    }

                    html += `<image data-id="${el.id}" href="${el.href}" x="${el.x}" y="${el.y}" width="${el.width}" height="${el.height}" opacity="${el.opacity}" clip-path="${el.clip !== 'rect' ? `url(#${clipId})` : ''}" class="${cls}" preserveAspectRatio="xMidYMid slice" />`;
                } 
                else if (el.type === 'circle') {
                    html += `<circle data-id="${el.id}" cx="${el.cx}" cy="${el.cy}" r="${el.r}" fill="${el.fill}" opacity="${el.opacity}" class="${cls}" />`;
                }
                else if (el.type === 'rect') {
                    html += `<rect data-id="${el.id}" x="${el.x}" y="${el.y}" width="${el.width}" height="${el.height}" fill="${el.fill}" opacity="${el.opacity}" class="${cls}" rx="4" />`;
                }
            });

            document.getElementById('svg-defs').innerHTML = defs;
            elementsLayer.innerHTML = html;
        }

        // Helper to convert URL to Base64 (Essential for SVG Export to Canvas)
        async function toBase64(url) {
            if (!url || url.startsWith('data:')) return url;
            try {
                const response = await fetch(url);
                const blob = await response.blob();
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });
            } catch (e) {
                console.warn("Failed to convert image to base64:", url);
                return url;
            }
        }

        // --- EXPORT LOGIC REPAIRED ---
        document.getElementById('exportBtn').addEventListener('click', async () => {
            const btn = document.getElementById('exportBtn');
            const originalText = btn.innerText;
            btn.innerText = "PREPARING...";
            btn.disabled = true;

            const canvas = document.getElementById('exportCanvas');
            const ctx = canvas.getContext('2d');
            const isH = state.orientation === 'H';
            const W = isH ? 1050 : 600;
            const H = isH ? 600 : 1050;
            
            // Set High Definition Canvas
            canvas.width = W * 2;
            canvas.height = H * 2;

            // Clear selection for clean export
            const oldSelected = state.selectedId;
            state.selectedId = null;
            render();

            // CLONE and PREPARE SVG for export
            // Browsers won't draw remote images to canvas from inside an SVG blob.
            // We must convert all <image> hrefs to Base64 first.
            const svgClone = svg.cloneNode(true);
            const images = svgClone.querySelectorAll('image');
            
            for (let imgEl of images) {
                const base64 = await toBase64(imgEl.getAttribute('href'));
                imgEl.setAttribute('href', base64);
            }

            svgClone.setAttribute('width', W);
            svgClone.setAttribute('height', H);
            
            // Inline fonts for the browser's image parser
            const style = document.createElement('style');
            style.textContent = `
                @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700;900&family=JetBrains+Mono&family=Playfair+Display:wght@700&family=Bebas+Neue&display=swap');
                text { font-family: 'Inter', sans-serif; }
            `;
            svgClone.prepend(style);

            const svgData = new XMLSerializer().serializeToString(svgClone);
            const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
            const url = URL.createObjectURL(svgBlob);

            const img = new Image();
            img.onload = () => {
                ctx.fillStyle = document.getElementById('col-bg').value;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.scale(2, 2);
                ctx.drawImage(img, 0, 0);
                
                const link = document.createElement('a');
                link.download = `NETCARD_${state.orientation}_${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png', 1.0);
                link.click();
                
                URL.revokeObjectURL(url);
                state.selectedId = oldSelected;
                render();
                btn.innerText = originalText;
                btn.disabled = false;
            };
            
            img.onerror = (err) => {
                console.error("Export failed:", err);
                state.selectedId = oldSelected;
                render();
                btn.innerText = originalText;
                btn.disabled = false;
            };

            img.src = url;
        });

        init();
    </script>
</body>
</html>

